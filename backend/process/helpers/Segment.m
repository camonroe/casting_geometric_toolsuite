classdef (Sealed) Segment < ProcessHelper
    
    properties ( GetAccess = public, SetAccess = private )
        
        edt_max
%         edt_threshold
        hotspot_index_list
        %largest_edt_sub
        %largest_edt_position
        centroid
        L
        W
        T
        volume
        shape_factor
        
    end
    
    
    methods ( Access = public )
        
        function obj = Segment( ...
                base_array, ...
                base_threshold, ...
                edt_array, ...
                segment_binary_array, ...
                mesh ...
                )
            
            assert( islogical( segment_binary_array ) );
            obj.edt_max = ...
                Segment.determine_edt_max( edt_array, segment_binary_array );
            
            % position
%             obj.edt_threshold = ...
%                 Segment.determine_edt_threshold( obj.edt_max );
            obj.hotspot_index_list = Segment.find_hotspot_index_list( ...
                segment_binary_array, ...
                base_array, ...
                base_threshold ...
                );
            obj.centroid = Segment.locate_centroid( ...
                obj.hotspot_index_list, ...
                size( segment_binary_array ), ...
                mesh.element.length, ...
                mesh.origin ...
                );
            
            
            [ obj.L, obj.W, obj.T, obj.volume, obj.shape_factor ] ...
                = Segment.determine_equivalent_plate_dimensions( ...
                obj.edt_max, ...
                segment_binary_array, ...
                obj.hotspot_index_list, ...
                mesh.element.length, ...
                mesh.element.volume ...
                );
            
        end
        
        
        function tr = to_table_row( obj )
            
            tr = [ ...
                { obj.edt_max } ...
                num2cell( obj.centroid ) ...
                { obj.L ...
                obj.W ...
                obj.T ...
                obj.volume ...
                obj.shape_factor } ...
                ];
            assert( numel( tr ) == obj.get_table_row_length() );
            
        end
        
    end
    
    
    methods ( Access = public, Static )
        
        function trn = get_table_row_names()
            
            trn = { ...
                'largest_edt_value', ...
                'centroid_x', ...
                'centroid_y', ...
                'centroid_z', ...
                'l', ...
                'w', ...
                't', ...
                'volume', ...
                'shape_factor', ...
                };
            
        end
        
    end
    
    
    methods ( Access = private, Static )
        
        function edt_max = determine_edt_max( ...
                edt_array, ...
                segment_binary_array ...
                )
            
            edt_array( ~segment_binary_array ) = 0;
            edt_max = max( edt_array( : ) );
            
        end
        
        
%         function edt_threshold = determine_edt_threshold( edt_max )
%             
%             % HACK it is entirely possible for two segments to have the same
%             % centroid if we use a thresholding method with the wrong threshold.
%             % BE CAUTIOUS!
%             COEFF = 1;
%             DIFF = 1;
%             edt_threshold = ( COEFF * edt_max ) - DIFF;
%             
%         end
        
        
        function hotspot_index_list = find_hotspot_index_list( ...
                segment_binary_array, ...
                array, ...
                threshold ...
                )
            
            max_val = max( array( segment_binary_array ), [], 'all' );
            segment_binary_array( array < ( max_val - threshold ) ) = 0;
            hotspot_index_list = find( segment_binary_array( : ) ).';
            
        end
        
        
        function centroid = locate_centroid( ...
                hotspot_index_list, ...
                array_size, ...
                element_length, ...
                mesh_origin ...
                )
            
            edt_threshold_array = zeros( array_size );
            edt_threshold_array( hotspot_index_list ) = 1;
            centroid = regionprops( ...
                edt_threshold_array + 1, ...
                'Centroid' ...
                );
            centroid = cat( 1, centroid( 2 ).Centroid );
            centroid = ...
                ( element_length .* centroid( :, [ 2 1 3 ] ) ) ...
                + mesh_origin;
            
        end
        
        
        function [ L, W, T, volume, shape_factor ] = ...
                determine_equivalent_plate_dimensions( ...
                edt_max, ...
                segment_binary_array, ...
                hotspot_index_list, ...
                element_length, ...
                element_volume ...
                )
            
            T = edt_max;
            
            dilated_segment = imdilate( ...
                segment_binary_array, ...
                conndef( 3, 'maximal' ) ...
                );
            geodesic = element_length .* double( bwdistgeodesic( ...
                dilated_segment, ...
                hotspot_index_list, ...
                'quasi-euclidean' ...
                ) );
            geodesic( isnan( geodesic ) ) = inf;
            geodesic( segment_binary_array ) = inf;
            geodesic_values = geodesic( geodesic < inf );
            
            L = max( geodesic_values( : ) );
            W = median( geodesic_values( : ) );
            
            volume = element_volume .* sum( segment_binary_array( : ) );
            shape_factor = ( L + W ) / T;
            
        end
        
    end
    
end

