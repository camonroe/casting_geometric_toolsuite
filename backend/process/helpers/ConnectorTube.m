classdef (Sealed) ConnectorTube < ProcessHelper
    
    properties ( GetAccess = public, SetAccess = private )
        
        tube_path
        radius_parametric_function
        trajectory
        fv
        
    end
    
    
    methods ( Access = public )
        
        % radius_parameter_function must be positive over the interval [ 0, 1 ]
        % only values from [ 0, 1 ] are checked, inclusive
        function obj = ConnectorTube( ...
                tube_path, ...
                radius_parametric_function ...
                )
            
            obj.tube_path = tube_path;
            obj.radius_parametric_function = radius_parametric_function;
            break_points = ConnectorTube.determine_break_points( ...
                obj.tube_path, ...
                obj.radius_parametric_function ...
                );
            spline_breaks = ConnectorTube.get_spline_breaks( ...
                break_points, ...
                tube_path ...
                );
            spline_queries = ConnectorTube.get_spline_queries( ...
                break_points, ...
                tube_path ...
                );
            obj.trajectory = ConnectorTube.compute_trajectory( ...
                tube_path.path_distance, ...
                tube_path.path, ...
                spline_breaks, ...
                spline_queries ...
                );
            parameter_queries = obj.tube_path.get_parameter_queries( ...
                length( spline_queries ) ...
                );
            obj.fv = ConnectorTube.sweep_tube( ...
                obj.trajectory, ...
                obj.radius_parametric_function( parameter_queries ) ...
                );
            
        end
        
        
        function tr = to_table_row( ~ )
            
            tr = {};
            
        end
        
    end
    
    
    methods ( Access = public, Static )
        
        function trn = get_table_row_names()
        
            trn = {};
            
        end
        
    end
    
    
    methods ( Access = private, Static )
        
        
        function break_points = determine_break_points( ...
                tube_path, ...
                radius_parameter_function ...
                )
            
            SAMPLE_SIZE = 1000; % HACK: probably sufficient
            sample_points = tube_path.sample_path_parameter( SAMPLE_SIZE );
            radius_samples = radius_parameter_function( sample_points );
            
            break_count = tube_path.path_length ./ max( radius_samples( : ) );
            break_points = tube_path.sample_path_parameter( break_count );
            
        end
        
        
        function spline_breaks = get_spline_breaks( ...
                break_points, ...
                tube_path ...
                )
            
            % min for sweep tube appearance
            MINIMUM_BREAK_COUNT = 3;
            % coeff for sweep tube appearance
            SPLINE_BREAK_COEFF = 0.5;
            break_count = max( ...
                MINIMUM_BREAK_COUNT, ...
                SPLINE_BREAK_COEFF .* length( break_points ) ...
                );
            spline_breaks = tube_path.get_spline_breaks( break_count );
            
        end
        
        
        function spline_queries = get_spline_queries( ...
                break_points, ...
                tube_path ...
                )
            
            % min from cc matrix to avoid rank deficient solution when
            % spline fitting
            MINIMUM_QUERY_COUNT = 3;
            SPLINE_QUERY_COEFF = 2;
            query_count = max( ...
                MINIMUM_QUERY_COUNT, ...
                SPLINE_QUERY_COEFF .* length( break_points ) ...
                );
            spline_queries = tube_path.get_spline_queries( query_count );
            
        end
        
        
        function trajectory = compute_trajectory( ...
                path_distance, ...
                raw_trajectory, ...
                spline_breaks, ...
                division_points ...
                )
            
            XS = ConnectorTube.evaluate_spline( ...
                path_distance, ...
                raw_trajectory( 1, : ), ...
                spline_breaks, ...
                division_points ...
                );
            YS = ConnectorTube.evaluate_spline( ...
                path_distance, ...
                raw_trajectory( 2, : ), ...
                spline_breaks, ...
                division_points ...
                );
            ZS = ConnectorTube.evaluate_spline( ...
                path_distance, ...
                raw_trajectory( 3, : ), ...
                spline_breaks, ...
                division_points ...
                );
            trajectory = [ XS; YS; ZS ];
            
        end
        
        
        function spline_values = evaluate_spline( ...
                parameter, ...
                values, ...
                breaks, ...
                parameter_queries ...
                )
            
            conditions = ConnectorTube.spline_end_conditions( ...
                parameter, ...
                values ...
                );
            
            % CITE: splinefit fex/13812-splinefit
            spline_polyform = splinefit( ...
                parameter, ...
                values, ...
                breaks, ...
                conditions, ...
                'r' ...
                );
            
            spline_values = ppval( spline_polyform, parameter_queries );
            
        end
        
        
        function conditions = spline_end_conditions( parameter, values )
            
            % end conditions:
            % first point pinned
            % second point first derivative equal to deriv of first two
            %  points
            xc = [ ...
                parameter( 1 ) ...
                parameter( 1 ) ...
                parameter( end ) ...
                parameter( end ) ...
                ];
            start_diff = ...
                ( values( 2 ) - values( 1 ) ) ...
                ./ ( parameter( 2 ) - parameter( 1 ) );
            finish_diff = ...
                ( values( end ) - values( end - 1 ) ) ...
                ./ ( parameter( end ) - parameter( end - 1 ) );
            yc = [ ...
                values( 1 ) ...
                start_diff ...
                values( end ) ...
                finish_diff ...
                ];
            cc = [ ...
                1 0 1 0;...
                0 1 0 1 ...
                ];
            conditions = struct( ...
                'xc', xc, ...
                'yc', yc, ...
                'cc', cc ...
                );
            
        end
        
        
        function radii = compute_radii( ...
                radius_parameter_function, ...
                break_points ...
                )
            
            radii = interp1( ...
                path_parameter, ...
                radius_parameter_function( path_parameter ), ...
                break_points ...
                );
            
        end
        
        
        function fv = sweep_tube( trajectory, radii )
            
            % issue with wrong-facing normals when generating
            % CITE: extrude fex/25086-extrude-a-ribbon-tube-and-fly-through-it-
            [ X, Y, Z ] = variable_cylindrical_sweep( ...
                trajectory, ...
                radii ...
                );
            fv = surf2patch( X, Y, Z, 'triangles' );
            
        end
        
    end
    
end

