classdef (Sealed) SegmentPair < ProcessHelper
    
    properties ( GetAccess = public, SetAccess = private )
        
        are_neighbors
        labels
        seeds
        euclidean_distance
        edt_difference
        boundary_index
        boundary_position
        boundary_edt
        boundary_distances
        
    end
    
    
    methods ( Access = public )
        
        function obj = SegmentPair( segmentation, labels, edt_profile, mesh )
            
            assert( isvector( labels ) );
            assert( isnumeric( labels ) );
            assert( numel( labels ) == 2 );
            
            obj.are_neighbors = false;
            obj.labels = labels;
            obj.seeds = { segmentation.segments( labels ).hotspot_index_list };
            obj.euclidean_distance = SegmentPair.compute_euclidean_distance( ...
                { segmentation.segments( labels ).centroid }, ...
                mesh.element.length ...
                );
            obj.edt_difference = SegmentPair.compute_edt_difference( ...
                segmentation, ...
                obj.labels ...
                );
            [ union, intersection ] = ...
                SegmentPair.compute_union_intersection( segmentation, labels );
            obj.boundary_position = [];
            obj.boundary_edt = [];
            if any( intersection( : ) )
                obj.are_neighbors = true;
                % todo compute geodesic dist, and pass to segment pair, then
                % logical indexing to get the value
                % should save lots of time
                [ obj.boundary_index, obj.boundary_edt ] = ...
                    SegmentPair.find_boundary_index( ...
                    obj.seeds, ...
                    union, ...
                    intersection, ...
                    edt_profile.scaled_interior ...
                    );
                obj.boundary_position = SegmentPair.compute_boundary_position( ...
                    size( segmentation.array ), ...
                    obj.boundary_index,...
                    mesh.element.length, ...
                    mesh.origin ...
                    );
                obj.boundary_distances = ...
                    SegmentPair.determine_boundary_distances( ...
                    size( segmentation.array ), ...
                    obj.seeds, ...
                    obj.boundary_index, ...
                    mesh.element.length ...
                    );
            end
            
        end
        
        
        function tr = to_table_row( obj )
            
            tr = [ ...
                num2cell( obj.labels ) ...
                { ...
                    obj.euclidean_distance ...
                    obj.edt_difference ...
                    obj.boundary_edt ...
                    } ...
                ];
            assert( numel( tr ) == obj.get_table_row_length() );
            
        end
        
    end
    
    
    methods ( Access = public, Static )
        
        function trn = get_table_row_names()
        
            trn = { ...
                'label_1' ...
                'label_2' ...
                'euclidean_distance' ...
                'edt_difference' ...
                'boundary_edt' ...
                };
            
        end
        
    end
    
    
    methods ( Access = private, Static )
        
        function euclidean_distance = compute_euclidean_distance( ...
                centroids, ...
                element_length ...
                )
            
            euclidean_distance = ...
                element_length .* vecnorm( centroids{ 1 } - centroids{ 2 } );
            
        end
        
        
        function edt_difference = compute_edt_difference( segmentation, labels )
            
            edt_values = [ segmentation.segments( labels ).edt_max ];
            edt_difference = abs( diff( edt_values ) );
            
        end
        
        
        function [ union, intersection ] = compute_union_intersection( ...
                segmentation, ...
                labels ...
                )
            
            % note names are to save memory
            union = ...
                segmentation.get_segment_image_with_boundary( labels( 1 ) );
            intersection = ...
                segmentation.get_segment_image_with_boundary( labels( 2 ) );
            union = union + intersection;
            intersection = ( union == 2 );
            union = union > 0;
            
        end
        
        
        function [ boundary_index, boundary_edt ] = find_boundary_index( ...
                seeds, ...
                union, ...
                intersection, ...
                edt_array ...
                )
            
            % intersection
            % find largest edt in intersection
            intersection_edt = edt_array;
            intersection_edt( ~intersection ) = -inf;
            boundary_edt = max( intersection_edt( : ) );
            boundary_indices = find( intersection_edt == boundary_edt );
            seeds = cell2mat( seeds );
            if length( boundary_indices ) > 1
                distances = bwdistgeodesic( union, seeds, 'quasi-euclidean' );
                distances( intersection_edt ~= boundary_edt ) = inf;
                minimum_distance = min( distances( : ) );
                closest_boundary_indices = find( distances == minimum_distance );
                if length( closest_boundary_indices ) > 1
                    warning("test");
                end
                boundary_indices = closest_boundary_indices( 1 );
            end
            boundary_index = boundary_indices;
            
        end
        
        
        function boundary_position = compute_boundary_position( ...
                sz, ...
                boundary_index, ...
                element_length, ...
                origin ...
                )
            
            boundary_position = ...
                element_length .* ind2sub_vec( sz, boundary_index ) + origin;
            
        end
        
        
        function boundary_distances = determine_boundary_distances( ...
                sz, ...
                seeds, ...
                boundary_index, ...
                element_length ...
                )
            
            boundary_sub = element_length .* ind2sub_vec( sz, boundary_index );
            first_sub = element_length .* ind2sub_vec( sz, seeds{ 1 } );
            boundary_distances( 1 ) = min( vecnorm( first_sub - boundary_sub, 2, 2 ) );
            second_sub = element_length .* ind2sub_vec( sz, seeds{ 2 } );
            boundary_distances( 2 ) = min( vecnorm( second_sub - boundary_sub, 2, 2 ) );
            
        end
        
    end
    
end

