% option_path = 'oo_options.json';
% input_path = 'C:\Users\wwarr\Desktop\test\base_plate.stl';
% op = Options( 'option_defaults.json', option_path, input_path, '' );
% 
% c = Component();
% c.legacy_run( input_path );
% m = Mesh();
% m.legacy_run( c, op.element_count );
% e = EdtProfile();
% e.legacy_run( m );
% s = Segmentation();
% s.legacy_run( e, m );
% f = Feeders();
% f.legacy_run( s, m );
% 
% oo = MultiObjectiveOrientationOptimizer( c, f, op.element_count );
% % or single objective
% objective_opt = ...
%     @(rotation_fn,angles)multiple_objective_opt( rotation_fn, angles );
% % or something else
% oo.run( objective_opt, op.population_count, op.generation_count );
[ full_pop, full_scores ] = oo.get_all_trials();

% plan to turn this into a product
% - abstract below code
% - abstract individual objectives into a data structure for use with optimizer
% in more robust manner
% - show quantiles more robustly (i.e. multiple quantiles) ??
% - create GUI that reacts to clicks by generating a 3D view of the geometry
% relative to XYZ primary axes in separate figure
%    [lat,lon] = inputm() to get click position
% - create selector to show the relevant visual for a given objective
% - include minimax in selector




count = size( full_scores, 2 );
interpolants = cell( count, 1 );
for i = 1 : size( full_scores, 2 )
    
    %interp_methods = { 'natural' };
    [ interp_methods, titles ] = multiple_objective_opt();
    interpolants{ i } = generate_scattered_spherical_interpolant( ...
        full_pop, ...
        full_scores( :, i ), ...
        interp_methods{ i } ...
        );
    
end
plot_angles = generate_sphere_angles( 1000 );

maximizer = max_interpolant( interpolants, true );
[ x, y ] = meshgrid( plot_angles( :, 1 ), plot_angles( :, 2 ) );
[ ~, min_index ] = min( maximizer( x, y ) );
min_angles = plot_angles( min_index );
[ fh, axh, ph ] = plot_response_surface( ...
    plot_angles, ...
    maximizer, ...
    [ 600 600 ], ...
    'maximum of features', ...
    '2d' ...
    );
divs = quantile_on_sphere_surface( maximizer, [ 0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99 ], 'natural' );
[ fh, axh, ph ] = plot_response_surface( ...
    plot_angles, ...
    @(x,y) double( maximizer(x,y) < divs( 1 ) ), ...
    [ 600 600 ], ...
    'minimax 1%', ...
    '2d' ...
    );

% [ fh, axh, ph ] = plot_response_surface( ...
%     plot_angles, ...
%     interpolant, ...
%     [ 600 600 ], ...
%     titles{ i }, ...
%     '3d' ...
%     );
% [ fh, axh, ph ] = plot_response_surface( ...
%     plot_angles, ...
%     interpolant, ...
%     [ 600 600 ], ...
%     titles{ i }, ...
%     '2d' ...
%     );
% divs = quantile_on_sphere_surface( interpolant, [ 0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99 ], interp_methods{ i } );
% [ fh, axh, ph ] = plot_response_surface( ...
%     plot_angles, ...
%     @(x,y) double( interpolant(x,y) < divs( 2 ) ), ...
%     [ 600 600 ], ...
%     titles{ i }, ...
%     '2d' ...
%     );